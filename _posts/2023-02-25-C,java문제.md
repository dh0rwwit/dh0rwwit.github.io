---
title: C,java 몇몇 문제들
author: dh0rwwit
date: 2023-03-11 08:00:00 +0900
categories: [Language,정처기]
tags: [C, java]
render_with_liquid: false
---

[3]. java 문제2
class ClassA() [
    ClassA() { // ClassA에속한 메소드 ClassA를 정의한다. ClassA 메소드는 클래스와 이름이 동일하다. 
    // 이렇게 클래스와 이름이 동일한 메소드는 클래스의 객체변수를 생성할 때 자동으로 생성된다. 
    // 이러한 메소드를 생성자라고 한다.
        System.out.print('A');
        this.prn(); // this는 현재 실행중인 메소드 ClassA가 속한 클래스를 가리키는 예약어이다.
    }
    void prn(){
        System.out.print('B');
    }
]

class ClassB extends ClassA{ // ClassB를 정의하고, ClassA를 부모로 둔 클래스임을 명시함
//  ClassA에 속한 변수와 메소드를 사용할 수 있다.
    ClassB() {
        super(); // 부모클래스의 생성자를 호출한다.
        System.out.print('D');
    }
    void prn() {
        System.out.print('E');
    }
    void prn(int x){
        System.out.print(x);
    }
}

public class Test{
    public static void main(String[] args){
        int x=7;
        ClassB cal = new ClassB(); // [클래스명] [객체변수] = [생성예약어] [생성자] 
        cal.prn(x); // prn은 처음에 클래스 ClassA로 선언되었지만 클래스 ClassB의 객체변수로 재정의 및 선언되었으므로, 7을 출력한다 
    }
}

/* 실행순서
    1. main함수 진입
    2. int x=7 선언 및 정의 
    3. ClassB cal = new ClassB(); <- ClassB 객체변수 cal선언
    4. ClassB 진입
    5. super(); 확인
    6. 상위 클래스인 ClassA로 진입
    7. A 출력
    8. this.prn() 코드확인...아래에 있는 prn()으로 이동하여 실행해야할 거 같지만...
    9. prn() 메소드는 ClassB에서 재정의(메소드 오버라이딩) 되었으므로 ClassB의 prn()메소드로 바로 이동한다.
    10. E 출력
    11. super(); 아래에 있는 D 출력 실행, 코드 ClassB cal = new ClassB(); 실행 완료됨
    12. cal.prn(x); 실행 -> classB에 있는 void prn(int x) 실행 -> 7 출력
*/

예제 2. 
public class Test{
    static int[] arr() { // int타입 값을 원소로갖는 배열 arr 선언
        int a[] = new int[4]; // int타입 값을 원소로 갖는 크기 4짜리 배열 선언
        int b = a.length; // b는 4
        for(int i = 0; i<b; i++) 
            a[i] = i; // a[0] = 0, a[1] = 1, ..., a[3]=3 대입
        return a; // arr()메소드 실행하면, 배열 a 반환
    }


    public static void main(String[] args){
        int a[] = arr();
        for (int i=0; i<a.length; i++) // a의 크기는 4로 정의 되었으므로
            System.out.print(a[i]+ " ");
    }
}
/* 실행순서
1. main() 진입
2. a[]선언 및 arr() 함수 확인
3. Test Class에서 arr() 찾음, 배열 a 생성 및 반환
4. main()안에서 a[]에 arr()에서 생성된 a대입
5. 0 1 2 3 출력
*/

예제 4. 
class Test {
    public static void main(String args[]){
        cond obj = new cond(3); // cond 클래스의 메소드를 사용할 수 있는 객체변수 obj를 선언
        obj.a=5; // 클래스 cond의 a에 5 대입...???
        int b = obj.func();
        System.out.print(obj.a+b);
    }
}
class cond {
    int a; // obj.a=5 즉, a=5가 대입
    public cond(int c) {
        this.a = c;
    }
    public int func(){
        int d=1;
        for (int i=1; i<a; i++)
            d += a*i;
        return a+d;
    }
}

/* 실행순서
    1. main() 진입
    2. cond obj = new cond(3); 코드 확인 후 cond 클래스 진입
    3. cond 생성자 public cond(int c) 확인
    4. cond(3)이므로 cond 클래스에서 매개변수로 쓰인 c는 3이고, 
    5. this.a = 3; -> cond클래스의 a의 값은 a=3이 된다.
    6. cond obj = new cond(3); 코드 종료

    7. obj.a=5; 에서 cond클래스의 a의 값은 5가된다.
    
    8. int b = obj.func(); 에서 func() 메소드 사용하는 것을 확인
    9. class cond에서 public int func(){} 로 진입.
    이 때 a는 3이 아닌 5이다.
    단계 7에서 a는 5로 정의되었기 때문이다.
    10. cond클래스의 func()메소드로 이동하여 for문 실행 후 a+d의 값을 반환.
    반복문 실행결과 d의 값은 1+5*1, 6+5*2, 16+5*3, 31+5*4 -> 51이된다.
    그리고 a+d의 값은 56이되므로 obj.func()의 결과는 56 -> b=56이된다.

    11. System.out.print(obj.a+b); 에서 obj.a=5이고, d는 56이므로 61을 출력한다.
*/

class Test {
    public static void main(String args[]){
        cond obj = new cond(3); 
        obj.a=5; 
        int b = obj.func();
        System.out.print(obj.a+b); // 
    }
}
class cond {
    int a; 
    public cond(int c) {
        this.a = c;
    }
    public int func(){
        int d=1;
        this.a=3; // func()에서 this.a=3이라고 지정해버리면, main함수의 obj.a=3이 되어버린다. 
        // cond클래스에서 사용되는 a의 값을 3이라고 지정하기 때문이다.  
        for (int i=1; i<a; i++)
            d += a*i; // 1+3*1, 4+3*2 -> 10
        return a+d; // 3+10 반환되고 main함수내의 obj.a는 3이된다.
    }
}

section 124. java활용
[1]. 추상 클래스와 형 변환 개요
- 추상 메소드 : (부모클래스 안에 있는 메소드이지만) 자식 클래스에서 재정의해야만 사용할 수 있는 메소드
- 추상 클래스 : 추상 메소드를 하나 이상 갖는 클래스
- 추상 메소드를 (부모클래스의 객체변수를 통해) 사용하려 할 때에는, 
생성자를 자식 클래스를 이용해야한다.
    -> [부모클래스] [객체변수] = [생성 예약어] [자식 클래스]

[2]. java문제

public class Test{
    public static void main(String[] args) {
        Animal a = new Chicken();
        a.show();
    }
}
abstract class Animal { // 추상 메소드를 갖고 있으므로 추상 클래스임
    String a = " is animal";
    abstract void look(); // 추상메소드 look() 선언
    void show() {
    	System.out.print("Zoo");
    }
}
class Chicken extends Animal {
    Chicken() {
        look();
    }
    void look(){
        System.out.println("Chicken"+a);
    }
    void display() {
        System.out.println("two wings");
    }
}
/* 실행순서
    1. main()진입
    
    2. Animal a = new Chicken(); 코드 실행, 
    객체변수의 생성자가 Chicken()임을 확인.
    자식 클래스인 Chicken으로 이동한 뒤 생성자 Chicken()으로 이동
    3. 자식클래스의 생성자까지 빌드가 이동한 뒤, 부모클래스로 이동해서 변수와 메소드들을 확인한다. -> 부모클래스 Animal로 이동
    (생성자가 없으면 자식클래스 class Chicken extends Animal까지만 가고 바로 부모클래스로 이동)
    4. String a = " is animal"을 대입하고
    5. look();이 추상메소드임을 확인
    6. 자식클래스인 Chicken 클래스로 가서 생성자인 Chicken 메소드로 간다
    7. 자식클래스의 생성자에서 look();을 확인하고
    8. void look();으로 이동한다.
    9. Chicken is animal 출력
    10. Animal a = new Chicken(); 종료

    11. a.show(); 확인
    12. Animal 클래스로 이동
    13. void show(){}로 이동해서 Zoo출력 
*/

예제 2. 
abstract class Vehicle {
    String name;
    abstract public String getName(String val);
    public String getName() {
    	return "Vehicle name : "+name;
    }
}
class Car extends Vehicle {
	private String name;
	public Car(String val) {
		name = super.name = val;
	}
	public String getName(String val) {
		return "Car name : "+val;
	}
	public String getName(byte[] val) {
		return "Car name : "+val;
	}
}
public class Test{
	public static void main(String[] args) {
		Vehicle obj = new Car("Spark");
		System.out.print(obj.getName());
	}
}
/* 실행순서
    1. main함수 진입
    2. Vehicle obj = new Car("Spark"); 진입
    3. 자식클래스은 Car 클래스로 이동
    4. public Car(String val)로 이동, val="Spark" 대입
    5. name=super.name=val <-자식클래스인 name, 부모클래스의 name에도 val를 입력한다.
    6. Vehicle obj = new Car("Spark") 종료

    7. System.out.print("obj.getName()"); 진입
    8. 객체변수 obj는 부모클래스 속성을 갖으므로, 우선 부모클래스인 Vehicle로 이동한다.
    9. 부모클래스인 Vehicle에서 public String getName() {} 진입
    - abstract public String getName(String val); 은 매개변수를 포함하고 있으므로 실행하지 않음

    10. Vehicle name : Spark 출력
*/

// 아래와 같이 getName에 매개변수를 넣으면, 자식클래스의 getName을 실행한다.
-> Car name : genesis 출력
abstract class Vehicle {
    String name;
    abstract public String getName(String val);
    public String getName() {
    	return "Vehicle name : "+name;
    }
}
class Car extends Vehicle {
	private String name;
	public Car(String val) {
		name = super.name = val;
	}
	public String getName(String val) {
		return "Car name : "+val;
	}
	public String getName(byte[] val) {
		return "Car name : "+val;
	}
}
public class Test{
	public static void main(String[] args) {
		Vehicle obj = new Car("Spark");
		String as = "genesis";
		System.out.print(obj.getName(as));
	}
}

;) class, 메소드, 객체변수란...
예를 들면,
class = 교실이라 생각하면 된다. 그리고 이러한 교실의 종류에는
과학교실, 수학교실, 영어교실, 등등 여러 교실이 있을 수 있다.
과학교실에서는 물리실험; 화학실험;을 할 수 있고,
수학교실에서는 매트랩응용;
영어교실에서는 영어대화;
등의 학습(작업)을 할 수 있다.

메소드는 클래스별로 객체변수가 배울 수 있는(사용할 수 있는) 기능이라고 보면 된다.

객체변수는 각 교실에서 각각의 작업을 공부한 학생이라 생각하면 된다.
그래서
과학교실에서 공부한 학생은 물리실험; 화학실험; 작업을 할 수 있고
수학교실에서 공부한 학생은 매트랩응용; 작업을 할 수 있다.
영어교실에서 공부한 학생은 영어대화;를 할 수 있다.

클래스 선언할 때는 ()를 붙이지 않는다.

;) 함수(메소드) 선언
1. public [return 되는 값의 자료형] [메소드이름]() {}

;) 상속할 때 코드의 빌드 순서와 원리 알기

